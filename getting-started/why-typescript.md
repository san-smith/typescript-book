# Почему TypeScript

Две главные цели TypeScript:

* Предоставить _опциональную систему типов_ для JavaScript.
* Предоставить запланированные фичи из будущих редакций JavaScript в текущие движки JavaScript.

Стремление к этим целям мотивировано ниже.

## Система типов TypeScript

Вы можете поинтересоваться: "**Зачем добавлять типы в JavaScript?**"

Типы доказали свою способность повышать качество и понятность кода. Большие команды \(Google, Microsoft, Facebook\) постоянно приходят к такому выводу. В частности:

* Типы увеличивают вашу скорость при выполнении рефакторинга кода. _Пусть лучше компилятор найдёт ошибки на этапе компиляции, вместо падения программы во время выполнения._
* Типы - это одна из лучших форм документации, которую вы можете иметь. _Сигнатура функции является теоремой, а тело функции - доказательством._

Однако у типов есть способ быть излишне формальными. TypeScript очень старательно удерживает барьер для входа как можно ниже. Вот как он это делает.

### Ваш код на JavaScript - это код на TypeScript

TypeScript обеспечивает безопасность типов во время компиляции для вашего кода на JavaScript. Это не удивительно, учитывая его имя. Самое замечательное, что типы являются полностью необязательными. Ваш JavaScript код в файле `.js` может быть переименован в файл `.ts` и TypeScript всё-равно вернёт валидный `.js`, эквивалентный оригинальному JavaScript файлу. TypeScript _намеренно_ и строго является надмножеством JavaScript с опциональной проверкой типов.

### Типы могут быть неявными

TypeScript пытается вывести как можно больше информации о типах, чтобы обеспечить безопасность типов при минимальных затратах производительности при разработке кода. Например, в следующем примере TypeScript узнает, что `foo` имеет тип `number`  ниже и выдаст ошибку во второй строке: 

```typescript
var foo = 123;
foo = '456'; // Ошибка: невозможно присвоить `string` для `number`

// foo явялется числом или строкой?
```

Этот тип вывода хорошо мотивирован. Если вы делаете вещи, подобные показанным в этом примере, то в остальной части кода вы не можете быть уверены, что `foo` имеет тип `number` или `string`. Такие проблемы часто возникают в больших многофайловых кодовых базах. Мы углубимся в правила вывода типов позже.

### Типы могут быть явными

Как мы уже упоминали ранее, TypeScript выведет столько, сколько может безопасно. Однако вы можете использовать аннотации для того чтобы:

1. Помочь вместе с компиляторм, и что более важно, задокументировать материал для следующих разработчиков, которые будут читать ваш код \(возможно это будете будущий вы!\).
2. Убедиться, что то, что видит компилятор, это то, что вы задумали, что он должен видеть. То есть ваше понимание кода соответствует алгоритмическому анализу кода \(выполняется компилятором\).

TypeScript использует постфиксную аннотацию типов, популярную в других _опционально_ аннотированных языках \(таких как ActionScript и F\#\).

```typescript
var foo: number = 123;
```

Теперь если вы сделаете что-нибудь неправильное, компилятор выдаст ошибку:

```typescript
var foo: number = '123'; // Ошибка: невозможно присвоить `string` в `number`
```

Мы обсудим все детали синтаксиса аннотаций, поддерживаемого TypeScript, в следующей главе.

### Типы являются структурными

В некоторых языках \(в частности, номинально типизированных\) статическая типизация приводит к ненужной формальности, потому что даже если _вы знаете_, что код будет работать нормально, семантика языка вынуждает вас копировать указание типов. Вот почему такие вещи, как [automapper для C\#](http://automapper.org/), _жизненно важны_ для C\#. В TypeScript, потому что мы действительно хотим, чтобы это было легко для разработчиков JavaScript с минимальной когнитивной перегрузкой, типы являются структурными. Это означает, что _утиная типизация_ является языковой конструкцией первого класса. Рассмотрим следующий пример. Функция `iTakePoint2D` будет принимать что угодно, что содержит ожидаемые ею значения \(`x` и `y`\):

```typescript
interface Point2D {
    x: number;
    y: number;
}
interface Point3D {
    x: number;
    y: number;
    z: number;
}
var point2D: Point2D = { x: 0, y: 10 }
var point3D: Point3D = { x: 0, y: 10, z: 20 }
function iTakePoint2D(point: Point2D) { /* do something */ }

iTakePoint2D(point2D); // точное соответствие - хорошо
iTakePoint2D(point3D); // дополнительная информация - хорошо
iTakePoint2D({ x: 0 }); // Ошибка: отсутствует информация об `y`
```

### Ошибки типов не мешают выдавать JavaScript

Чтобы упростить миграцию кода JavaScript в TypeScript, даже если есть ошибки компиляции, по умолчанию TypeScript _будет выдавать допустимый JavaScript_ как можно лучше. Например:

```typescript
var foo = 123;
foo = '456'; // Error: cannot assign a `string` to a `number`
```

будет превращено в следущий js:

```typescript
var foo = 123;
foo = '456';
```

Таким образом, вы можете постепенно обновлять свой код JavaScript до TypeScript. Это сильно отличается от того, как работают компиляторы многих других языков, и это еще одна причина для перехода на TypeScript.

### Типы могут быть окружающими

Основная цель разработки TypeScript состояла в том, чтобы позволить вам безопасно и легко использовать существующие библиотеки JavaScript в TypeScript. TypeScript делает это посредством _объявления \(declaration\)_. TypeScript предоставляет вам скользящую шкалу того, как много или как мало усилий вы хотите приложить в своих объявлениях. Чем больше усилий вы вкладываете, тем больше безопасности типов и интеллектуального кода вы получаете. Обратите внимание, что объявления для большинства популярных библиотек JavaScript уже написаны для вас [сообществом DefiniteTyped,](https://github.com/borisyankov/DefinitelyTyped) поэтому для большинства целей:

1. Файлы объявлений уже существуют.
2. Или, по крайней мере, у вас есть обширный список хорошо рассмотренных шаблонов объявлений TypeScript.

В качестве быстрого примера того, как вы создадите свой собственный файл объявлений, рассмотрим тривиальный пример [jquery](https://jquery.com/). По умолчанию \(как и следовало ожидать от хорошего JS-кода\) TypeScript ожидает, что вы объявите \(то есть где-нибудь используете var\) переменную перед использованием.

```typescript
$('.awesome').show(); // Ошибка: невозможно найти имя `$`
```

В качестве быстрого исправления _вы можете сказать TypeScript_, что действительно есть что-то, называемое `$`:

```typescript
declare var $: any;
$('.awesome').show(); // Okay!
```

Если вы хотите, вы можете использовать это базовое определение и предоставить дополнительную информацию, чтобы защитить вас от ошибок::

```typescript
declare var $: {
    (selector:string): any;
};
$('.awesome').show(); // Okay!
$(123).show(); // Ошибка: selector должен быть строкой
```

Мы подробно обсудим детали создания объявлений TypeScript для существующего JavaScript позже, когда вы узнаете больше о TypeScript \(например,  такие вещи как `interface` и `any`\).

## Будущий JavaScript =&gt; Сейчас

TypeScript предоставляет ряд функций, которые запланированы в ES6 для текущих движков JavaScript \(которые поддерживают только ES5 и т. д.\). Команда TypeScript активно добавляет эти функции, и этот список будет только увеличиваться со временем, и мы рассмотрим это в своем собственном разделе. Но в качестве пробы здесь приведен пример класса:

```typescript
class Point {
    constructor(public x: number, public y: number) {
    }
    add(point: Point) {
        return new Point(this.x + point.x, this.y + point.y);
    }
}

var p1 = new Point(0, 10);
var p2 = new Point(10, 20);
var p3 = p1.add(p2); // { x: 10, y: 30 }
```

и прекрасная стрелочная функция:

```typescript
var inc = x => x+1;
```

### Резюме

В этом разделе мы показали вам мотивацию и цели дизайна TypeScript. Теперь мы можем копаться в мельчайших деталях TypeScript.

    

